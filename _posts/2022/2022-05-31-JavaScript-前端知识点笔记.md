---
layout: post
title: 前端知识点笔记
date: 2022-05-31 14:59:40 +08:00
categories: [JavaScript,CSS,HTTP]
---

# 前端知识点笔记

## 浏览器

#### 页面渲染过程

- 浏览器向DNS服务器发起请求获取ip地址
- 向ip地址发起请求建立TCP连接
- 请求url地址资源
- 服务器处理请求后返回数据
- 浏览器对相应内容进行解析
- 解析构建DOM树与CSSOM树并合并为渲染树
- 计算渲染树布局数据
- 渲染到浏览器页面
    - async 异步加载脚本，加载完无论是DOMContentLoaded事件前后立即执行，多个async脚本执行顺序按照加载完成先后。
    - defer脚本加载不阻塞html解析，全部在DOMContentLoaded事件之前执行，并且会按照从上到下的定义顺序依次执行。

#### 浏览器缓存

##### 强缓存

不向服务器发送请求，直接从缓存读取资源

- Expires

  过期时间，HTTP/1时代产生的属性。是一个具体的时间点，等于 `max-age` + 请求时间。若修改了本地时间，则可能失效。目前仅作不支持HTTP/1.1的兼容性使用，

- Cache-Control

  HTTP/1.1。一下是各种取值：

    - **public** 可以被客户端和代理服务器缓存
    - **private** 只能被客户端缓存
    - **max-age=30** 缓存30秒后就过期
    - **s-max-age=30** 只对代理服务器有效，30秒后过期
    - **no-store** 不缓存
    - **no-cache** 非字面意思，客户端缓存响应但是由服务器判断是否使用缓存数据。就是不使用 `Cache-control` 控制缓存是否有效，由 `Etag` 或 `Lat-Modified` 来确认是否有效
    - **max-stale=30** 缓存过期30秒内依然可以使用缓存数据，若不指定age值，则表示浏览器愿意接收任何age的响应

##### 协商缓存

需要向服务器确认缓存是否有效

- `Etag`和`If-None-Match`

  第一次请求的时候会往响应头添加etag，返回的是一个校验码，ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。后续请求该资源文件会往请求头添加`If-None-Match`值来判断是否命中缓存。

- `Last-Modify` 和`if-modified-since`

  第一次请求的时候会往响应头添加最后修改时间，当浏览器再次请求该资源时，request的请求头中会包含 `if-modified-since`，该值为缓存之前返回的`Last-Modify`


## CSS

#### 定位

- #### flex

- 轴

    - 主轴

      水平轴，默认从左至右，即start至end

    - 交叉轴

      纵轴，默认从上到下，也是start到end

- 容器

    - 父容器

      ``justify-content``

      > 子元素在主轴上的对齐方式，

      ``align-items``

      > 子元素在交叉轴上的对齐方式

      ``flex-wrap``

      > 子容器的换行方式

      `flex-flow`

      > 两个参数，分别是flex-direction 和 flex-wrap

      `align-content`

      > 将子容器视为一个整体来设置子容器的交叉轴排列方式，仅子元素有多行的情况下生效，或 `flex-wrap` 设置为 `wrap`

    - 子容器

      `align-self`

      > 单独设置子容器如何沿交叉轴排列，如父容器设置了align-items属性，子容器设置了align-self,则以子容器align-self为准;

      `flex`

      > 默认值为0 1 auto;

      `flex-grow`

      > 定义父容器有多余空间时如何子元素如何分配给子元素，为所有子项的这个属性值相加后按自身属性值所占比例分配;

      `flex-shrink`

      > 为收缩系数值;

      `flex-basis`

      > 指定了 flex 元素在主轴方向上的初始大小。如果不使用 `box-sizing` 改变盒模型的话，那么这个属性就决定了 flex 元素的内容盒（content-box）的尺寸,当一个元素同时被设置了 `flex-basis` (除值为 `auto` 外) 和 `width` (或者在 `flex-direction: column` 情况下设置了`height`) , `flex-basis` 具有更高的优先级;

      `order`

      > 子容器的排列顺序，默认为0，数值越小越靠前


## JavaScript

#### 异步调度器 / 并发控制

#### 事件循环机制

js的执行机制是单线程的；核心就是事件循环，每次函数调用都是一个宏任务，而Promise和MutationObserver是属于微任务，setTimeout和setInterval等定时器属于宏任务；当前的宏任务执行完之后会检查微任务队列，不为空则依次执行全部微任务，微任务全部执行完之后开始执行渲染任务，然后继续

宏任务 --> 微任务 --> 渲染 --> 宏任务... 一直循环

#### 异步事件怎么进行的回调

#### ES6

### apply

通过传入一个对象与参数数组来完成函数调用，其中原理是用传入对象来执行函数且参数数组有多少个参数就执行多少次，与call的区别就是参数传递格式的区别，apply传参是一个数组，call是第二个参数开始的所有参数，并且所有参数一次全部传入执行一次

#### js实现动画

操作css的animation属性完成动画，

利用requestAnimationFrame这个api，但需要自己计算每次的参数

#### Promise原理

Promise 也还是使用回调函数，只不过是把回调封装在了内部，使用上一直通过 then 方法的链式调用。

它本身内部维护一个状态和一个callbacks队列，then函数会把传入的回调函数放进内部回调队列，并在状态为成功之后，也就是resolve调用之后依次执行，catch与then是一样的原理

## 模块化、工程化

#### webpack loader如何工作

依次加载每一个loader，遇到有pitch方法的立即执行这个方法，否则继续加载下一个loader。配置的loader是按照从后往前执行的，除了定义了pitch方法的是按照加载顺序从前往后执行，

## HTTP

#### 三次握手

SYN：同步序列编号（Synchronize Sequence Numbers）

第一次握手，由客户端发送`syn`包（syn=j）到服务器，并进入`SYN_SENT`状态，等待服务器确认

第二次握手，当服务端收到`syn`包并确认客户端的SYN，同时向客户端发送自己的SYN包，（syn=k），即SYN+ACK包，并进入`SYN_RECV`状态

第三次握手，客户端受到服务端的SYN+ACK包向服务端发送确认包ACK，此包发送完毕即进入连接成功状态

#### 四次挥手

**第一次挥手**，客户端发出连接释放报文，并且停止发送数据，客户端进入FIN-WAIT-1（终止等待1）状态

**第二次挥手**，服务端收到客户端连接释放报文，发出确认报文，此时进入`CLOSE-WAIT`状态，到此时，客户端向服务端的方向就释放了，连接处于半关闭状态，但是服务器如果还要发送数据，客户端也会接受，这个状态会持续一段时间。

客户端收到确认请求后进入`FIN-WAIT-2`状态，此时依然保持可接收服务端发送数据的状态。

**第三次挥手**，服务端数据发送完毕，向客户端发送连接释放的报文请求，然后进入到`LASTACK`状态，等待客户端确认。

**第四次挥手**，客户端收到服务器的连接释放报文后，必须发出确认，此时客户端就进入了`TIME-WAIT`状态，此时TCP连接还未释放，必须经过最长报文段寿命的时间后，当客户端撤销相应的`TCB`后，才进入`CLOSED`状态。

服务端只要收到客户端的确认，立即进入`CLOSED`状态，同样，撤销TCB后，就结束了这次的TCP连接。

所以服务端更早结束TCP连接

## 设计模式

- 观察者模式
